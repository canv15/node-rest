node-restify
============

A middleware of connect/express to support RESTFul style API service.

It route http request to special handler by request url patter, and binding path or query parameters to arguments of handler. It can support asynchronize response and compliance with 'Promise' result. It can also cooperate with other popular middleware like body-parser, cookie-parser ...


## Installation

This package is available on 'npm' as: `node-restify`

``` sh
npm install node-restify
```

## Usage

### Quick Start

```
var http = require('http'),
	connect = require('connect'),
	rest = require('node-restify');

var app = connect()
	.use(rest());

http.createServer(app).listen(8080);	

resource('/rest', function() {
	get('/node-restify/{name}',function(name) {
		return { msg: 'hello ' + name};
	});
});
```
Access url http://localhost:8080/rest/node-restify/tony from your brower, you can get return message
```
{"msg":"hello tony"}
```

### Configure Node-restify

The code of resources should seperate from server.js or app.js, we can put them into the foldler resources and organize them to folder structure, like this:
```
-------node_modules
	|--server.js
	|--resources
		|--resource-a.js
		|--resource-b.js
		|--sub-folder
			|--resource-c.js
			|--resource-c.js
			...
```
The root folder name 'resource' is default location if your code like this:
```
...
	use(rest())
...
```
You can change it by pass a string to rest(), like this:
```
...
	use(rest(your_location))
...
```
You also can pass a config object to rest to get more control, like this:
```
...
	use(rest{
		mode: 'dev',  							//default is 'product'
		logger: console, 						//default log can not output anything
		scopes: ['pathParams','query','body'],  //default value is ['pathParams','query']		
		resourceLocation: your_location			//default value is 'resources'
	})
...
```
'product' mode is default mode, in this mode all of resource will load once at server start, your can change it to 'dev' mode which will cause reload all resource at every time node-restify receive a http request, in this case, you can change resource code on fly.

If your have favorite logger component like log4js, you can inject it to node-restify, you even can register a logger factory function. You can just inject 'console' object to node-restify, if you only need to detail information when it work 

'scopes' used by parameter binding. Path parameters will be parsed from http request url by url-pattern, like '/rest/node-restify/{name}', which defined by resource defination. And these path parameters will auto binding to arguments of handler function, like function(name) { ... }. Same thing will happend with query parameter,like /?name=test&age=100, The sequence of scope will decide arguments binding sequence, in default, arguments will get value from path parameters first, then query parameter. Infact all of these scopes are the properties of httpRequest, like req.query, req.pathParms,which generated by node-restify or some middleware. So, you can change binding sequence or add new scope to it, for example, after use middleware 'body-parse', req.body can be accessed, 'body' can add in scopes.

,resourceLocation can specify the location of resource root folder, node-restify will scan this folder recursively.  

### Define Resource 
Resouce define is very simple, like this:
```
resource('/rest', function() {
	get('/node-restify/{name}',function(name) {
		return { msg: 'hello ' + name};
	});

	post('/{id}', function(id) {
		.....
	});

	...
});
```
You can put one resource one resouce file, you also put all resources in one file, You even can nest resource like this:
```
resource('/catalog', function() {
	resource('/foo', function() {
		get('/bar', function() {
			...
		});
	});
	
	resource('/bar', function() {
		get('/bar', function() {
			...
		});
	});
});
```
The matched url are '/catalog/foo/bar' and '/catalog/bar/bar'.

'get','post','put','del' is global functions which add by node-restify used by register handler to HTTP Method 'GET', 'POST', 'PUT', 'DELETE'. If you need catch others HTTP Method, there is other method 'httpMethod(method)', you can ues it get new register function by pass method to it. Global function meansyou don't have to import anything, just use it, like test framework 'mocha'.

Path parameter can be specified when register resource by function 'resource' ,'get'..., like this:
```
resource('/{param1}', function() {
	get('/{param2}/{param3}',function(name) {
		return { msg: 'hello ' + name};
	});

	...
});
```
'{}' indicate parameter.

Any httpMethod can omit the path, just handler function, like this:
```
...
	get(function() {
		...
	});
...
```

### Handler function
Handler function will process http reqest, and return result to transform JSON format to client.
node-restify will binding argument and call handler when a http request matched a resource defination. arguments will be binded by sequence when defined in config object. The result of handler SHOULD be object which can be serilized to string with JSON format. node-restify will put this result to http response body. In this case, 200 will be as http return code, and 'Content-Type':'application/json' will be set to response header.

```
...
	get('/foo', function(name, age, id ....) {
		....

		return {
			name: ...
			age: ...
			....
		};
	});

...
```

If no result returned, or undifined returned by handler, 204 will be as http code returned to client by node-restify

'httpRequest' can be used as argument of handler, if you want to refer http request, like this:
```
...
	get('/foo', function(otherParameter1, httpRequest, otherParams2) {
		...
	}):
...
```
500 will be return as http code to client, if any exception throw by handler. You can customize return code and message by throw your error by folowing format:
```
...
	get('/foo', function() {
		...
		throw {
			code:503,
			msg: '........'
		};
	}
...
```

### Asynchronize Response
Asynchronize is most important feature of nodejs. It also be supported by node-restify. You can choose two way to implement it in node-restify.

#### Full control with httpResponse
You can get full control of http response by declare 'httpResponse' as argument of handler. In that case, node-restify just route http request to handler, can binding all of arguments, then just call handler, that's all. Nothiing will write back to client by node-restify, include http return code, header..., you must control reponse by yourself. like this:
```
...
	get(otherParameter1,otherParameter2, httpResponse) {
		...
		asyncCall(....,function(callbackResult) {
			httpResponse.writeHeader(200,......)
			.....
			httpResponse.write(......);
			httpResponse.end(....);
		});
	});
...
```

#### Promise Style Result
node-restify dose not depend any pormise package so far, but it support 'Promise style Result'. That means if a promise returned by handler, node-restify will receive result, and call 'then' function to get real date and format to JSON string back to client, as same, fail will be called if any exception happend. 'Promise style Result' is just a object which have function 'then', and 'fail', so it is easy to get by many popular promise libs, like 'Q', 'promise', sameple code:
```
...
resource('/rest', function() {
	get(function() {
		var deferred = Q.defer();
		someAsyncCall(function(callbackResult){
			return deferred.resolve({msg:callbackResult});
		});
		return deferred.promise;
	});
});
...
```
##License
`node-restify` is licensed under the [MIT License][mit-license-url].


